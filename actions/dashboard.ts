// app/actions/dashboard.ts 'use server'; import { auth } from '@/auth'; import { db } from '@/lib/db'; import { redirect } from 'next/navigation'; import { emailSearchSchema, chatMessageSchema, searchQuerySchema } from '@/lib/validations/dashboard'; import sanitizeHtml from 'sanitize-html'; import type { DashboardData, UserLog, ChatMessage } from '@/lib/types/dashboard'; // Auth helper async function requireAdminAuth() { const session = await auth(); if (!session?.user?.id) { redirect('/auth/login'); } if (!['ADMIN', 'MANAGER'].includes(session.user.role || '')) { redirect('/403'); } return session; } // Sanitize HTML content to prevent XSS function sanitizeContent(content: string): string { return sanitizeHtml(content, { allowedTags: [], // No HTML tags allowed allowedAttributes: {}, disallowedTagsMode: 'escape' }); } // Fetch all dashboard data (server-side) export async function getDashboardData(): Promise<DashboardData> { await requireAdminAuth(); try { // Parallel fetch with 10s timeout per request const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 10000); const [statsRes, healthRes, toolsRes] = await Promise.all([ fetch(${process.env.NEXT_PUBLIC_APP_URL}/api/admin/mcp/stats, { signal: controller.signal, cache: 'no-store' }), fetch(${process.env.NEXT_PUBLIC_APP_URL}/api/admin/mcp/system-health, { signal: controller.signal, cache: 'no-store' }), fetch(${process.env.NEXT_PUBLIC_APP_URL}/api/admin/mcp/tools-usage, { signal: controller.signal, cache: 'no-store' }) ]); clearTimeout(timeoutId); if (!statsRes.ok || !healthRes.ok || !toolsRes.ok) { throw new Error('Greška pri učitavanju podataka'); } const [stats, health, toolsUsage] = await Promise.all([ statsRes.json(), healthRes.json(), toolsRes.json() ]); return { stats, health, toolsUsage }; } catch (error) { console.error('Error fetching dashboard data:', error); // Return safe defaults instead of throwing return { stats: { totalQueries: 0, topTools: [], recentActivity: [] }, health: { users: { total: 0, active: 0 }, contracts: { total: 0, active: 0 }, complaints: { pending: 0 }, humanitarians: [], systemStatus: 'error', lastChecked: new Date().toISOString() }, toolsUsage: { tools: [], totalUsage: 0, period: 'all time', lastUpdated: new Date().toISOString() } }; } } // Search user logs by email export async function searchUserLogsByEmail( email: string ): Promise<{ logs: UserLog[]; error?: string }> { await requireAdminAuth(); // Validate input const validation = emailSearchSchema.safeParse({ email }); if (!validation.success) { return { logs: [], error: validation.error.errors[0].message }; } try { // Find user by email const user = await db.user.findUnique({ where: { email: validation.data.email }, select: { id: true } }); if (!user) { return { logs: [], error: 'Korisnik nije pronađen' }; } // Fetch user's MCP logs const logs = await db.activityLog.findMany({ where: { userId: user.id, action: { startsWith: 'MCP_QUERY_' } }, select: { id: true, details: true, createdAt: true }, orderBy: { createdAt: 'desc' }, take: 50 // Limit results }); return { logs }; } catch (error) { console.error('Error searching user logs:', error); return { logs: [], error: 'Greška pri pretrazi logova' }; } } // Send chat message to AI export async function sendChatMessage( messages: ChatMessage[] ): Promise<{ message: ChatMessage; error?: string }> { const session = await requireAdminAuth(); // Validate input const validation = chatMessageSchema.safeParse({ messages }); if (!validation.success) { return { message: { role: 'assistant', content: '' }, error: 'Nevažeći format poruke' }; } try { const lastMessage = messages[messages.length - 1]; const lowerInput = lastMessage.content.toLowerCase(); // Handle humanitarian orgs query directly (bypass AI) if (lowerInput.includes('humanitarne') || lowerInput.includes('kratki brojevi')) { const orgs = await db.humanitarianOrg.findMany({ where: { isActive: true, shortNumber: { not: null } }, select: { name: true, shortNumber: true, phone: true }, take: 50, orderBy: { name: 'asc' } }); const content = orgs.length ? orgs .map( (org, idx) => ${idx + 1}. ${sanitizeContent(org.name)} - Kratki broj: ${ org.shortNumber || 'N/A' }${org.phone ? - Telefon: ${sanitizeContent(org.phone)} : ''} ) .join('\n') : 'Nema pronađenih humanitarnih organizacija sa kratkim brojevima.'; // Log the query await db.activityLog.create({ data: { action: 'MCP_QUERY_SEARCH_ENTITIES', entityType: 'humanitarian_org', details: JSON.stringify({ query: 'humanitarian orgs with short numbers' }), userId: session.user.id, severity: 'INFO' } }); return { message: { role: 'assistant', content } }; } // Call AI chat API const response = await fetch(${process.env.NEXT_PUBLIC_APP_URL}/api/chat, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ messages: validation.data.messages }), signal: AbortSignal.timeout(30000) // 30s timeout }); if (!response.ok) { throw new Error('AI chat API greška'); } const data = await response.json(); // Sanitize AI response to prevent XSS const sanitizedMessage: ChatMessage = { role: 'assistant', content: sanitizeContent(data.message.content) }; return { message: sanitizedMessage }; } catch (error) { console.error('Chat error:', error); return { message: { role: 'assistant', content: '' }, error: error instanceof Error && error.name === 'TimeoutError' ? 'Zahtev je istekao, pokušajte ponovo' : 'Greška u komunikaciji sa AI sistemom' }; } }