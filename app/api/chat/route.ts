// app/api/chat/route.ts - Potpuno a≈æurirana verzija sa AI Context Builder

import { auth } from '@/auth';
import { NextRequest, NextResponse } from 'next/server';
import { InternalMcpServer } from '@/lib/mcp/internal-server';
import { AIContextBuilder } from '@/lib/mcp/ai-context-builder';
import type { McpContext } from '@/lib/mcp/types';

const mcpServer = new InternalMcpServer();
const pendingActions: Record<string, { toolName: string, params: any }> = {};
const userToolHistory: Record<string, string[]> = {}; // üÜï Praƒáenje tool usage

export async function POST(req: NextRequest) {
  try {
    console.log('üî• API Chat called');
    
    const body = await req.json();
    const { message } = body;

    if (!message || typeof message !== 'string') {
      return NextResponse.json(
        { error: 'Message is required' },
        { status: 400 }
      );
    }

    const session = await auth();
    console.log('üë§ Session:', session?.user);
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized - Please log in' },
        { status: 401 }
      );
    }

    const context: McpContext = {
      userId: session.user.id,
      userRole: session.user.role || 'USER'
    };

    console.log('üì® Chat request:', { message, context });

    // üÜï Praƒáenje tool historije za contextual hints
    if (!userToolHistory[context.userId]) {
      userToolHistory[context.userId] = [];
    }

    // Koristi AI ako je dostupan API key i poruka je dovoljno duga
    const useAI = process.env.OPENROUTER_API_KEY && message.length > 5;
    
    const response = useAI 
      ? await handleAIQuery(message, context, userToolHistory[context.userId])
      : await handleQuery(message, context);

    return NextResponse.json({ 
      response,
      timestamp: new Date().toISOString()
    });

  } catch (error: any) {
    console.error('‚ùå Chat API error:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function GET(req: NextRequest) {
  try {
    const session = await auth();
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const tools = mcpServer.getToolsForRole(session.user.role || 'USER');
    
    return NextResponse.json({
      status: 'OK',
      userRole: session.user.role,
      toolsCount: tools.length,
      tools: tools.map(t => ({
        name: t.name,
        category: t.category,
        description: t.description
      }))
    });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// ‚úÖ A≈ΩURIRANA FUNKCIJA - AI-powered sa AI Context Builder
async function handleAIQuery(
  query: string, 
  context: McpContext,
  recentTools: string[]
): Promise<string> {
  const userId = context.userId;

  // 1Ô∏è‚É£ Provera potvrde prethodne akcije
  if (query.trim().toLowerCase() === 'potvrdjujem' && pendingActions[userId]) {
    const { toolName, params } = pendingActions[userId];
    delete pendingActions[userId];

    try {
      const result = await mcpServer.executeTool(toolName, params, context);
      
      // üÜï Dodaj u tool history
      userToolHistory[userId] = [...(userToolHistory[userId] || []), toolName].slice(-10);
      
      return formatToolResponse(toolName, result);
    } catch (error: any) {
      console.error('Tool execution error:', error);
      return `‚ùå Gre≈°ka pri izvr≈°avanju alata: ${error.message || error}`;
    }
  }

  // 2Ô∏è‚É£ Generi≈°i optimizovan AI prompt kori≈°ƒáenjem AI Context Builder
  try {
    const tools = mcpServer.getToolsForRole(context.userRole);
    
    // üÜï Koristi AIContextBuilder za stvaranje system prompta
    const systemPrompt = AIContextBuilder.buildSystemPrompt(
      tools,
      context.userRole,
      context
    );

    // üÜï Dodaj contextual hints
    const hints = AIContextBuilder.generateContextualHints(
      recentTools,
      context.userRole
    );

    const fullPrompt = `${systemPrompt}${hints}

---

**KRITIƒåNA PRAVILA ZA KORI≈†ƒÜENJE ALATA:**

1. **Format odgovora kada predla≈æe≈° alat:**
   \`\`\`
   Koristim alat: [IME_ALATA] sa parametrima: {"key": "value"}
   \`\`\`

2. **Kada tra≈æi≈° od korisnika da potvrdi:**
   - Jasno objasni ≈°ta ƒáe alat uraditi
   - Napi≈°i: "Da li ≈æeli≈° da potvrdim ovu akciju? (Odgovori sa 'potvrdjujem')"

3. **Za READ alate (get_*):** Automatski ih koristi bez potvrde
4. **Za WRITE alate (create_*, update_*, delete_*):** UVEK tra≈æi potvrdu

5. **Uvek odgovaraj na srpskom jeziku**

**Trenutni upit korisnika:** ${query}`;

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
        'X-Title': 'MCP Contract Manager'
      },
      body: JSON.stringify({
        model: 'deepseek/deepseek-chat',
        messages: [
          { role: 'system', content: fullPrompt },
          { role: 'user', content: query }
        ],
        temperature: 0.7,
        max_tokens: 800 // üÜï Poveƒáano zbog du≈æeg system prompta
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter error:', errorText);
      return handleQuery(query, context); // fallback
    }

    const data = await response.json();
    const aiResponse = data.choices[0]?.message?.content || 'Nema odgovora';

    // 3Ô∏è‚É£ Parsiranje AI odgovora za detekciju tool calla
    const toolMatch = aiResponse.match(/Koristim alat:\s*(\w+)\s*(?:sa parametrima:\s*(\{.+?\}))?/is);
    
    if (toolMatch) {
      const toolName = toolMatch[1];
      let params: any = {};

      if (toolMatch[2]) {
        try {
          params = JSON.parse(toolMatch[2]);
        } catch (e) {
          console.warn('Failed to parse tool params:', toolMatch[2]);
        }
      }

      // üÜï Proveri da li je WRITE operacija
      const tool = tools.find(t => t.name === toolName);
      const isWriteOperation = tool?.category === 'write';

      if (isWriteOperation) {
        // WRITE operacija - ƒçuvaj u pending i tra≈æi potvrdu
        pendingActions[userId] = { toolName, params };
        return `${aiResponse}\n\n‚ö†Ô∏è **Ovo je operacija izmene podataka.**\n\n` +
               `Da li ≈æeli≈° da potvrdim akciju? Odgovori sa **"potvrdjujem"**.`;
      } else {
        // READ operacija - izvr≈°ava se odmah
        try {
          const result = await mcpServer.executeTool(toolName, params, context);
          
          // üÜï Dodaj u tool history
          userToolHistory[userId] = [...(userToolHistory[userId] || []), toolName].slice(-10);
          
          return formatToolResponse(toolName, result);
        } catch (error: any) {
          console.error('Tool execution error:', error);
          return `‚ùå Gre≈°ka pri izvr≈°avanju alata: ${error.message}`;
        }
      }
    }

    // 4Ô∏è‚É£ Ako AI ne poziva alat, vrati njegov odgovor
    return aiResponse;

  } catch (error: any) {
    console.error('AI Query error:', error);
    return handleQuery(query, context); // fallback na keyword matching
  }
}

// ‚úÖ Originalna keyword-based funkcija (fallback) - OSTAJE ISTA
async function handleQuery(query: string, context: McpContext): Promise<string> {
  const lowerQuery = query.toLowerCase();

  // Help request
  if (lowerQuery.includes('koje alate') || 
      lowerQuery.includes('≈°to mo≈æe≈°') || 
      lowerQuery.includes('available tools') ||
      lowerQuery.includes('list tools') ||
      lowerQuery.includes('help')) {
    return formatAvailableTools(context.userRole);
  }

  // Debug/status
  if (lowerQuery.includes('debug') || lowerQuery.includes('status')) {
    return getSystemStatus();
  }

  // Contracts
  if (lowerQuery.includes('ugovor') || lowerQuery.includes('contract')) {
    const result = await mcpServer.executeTool('get_contracts', {
      limit: 10,
      offset: 0
    }, context);
    return formatToolResponse('get_contracts', result);
  }

  // Providers
  if (lowerQuery.includes('provajder') || lowerQuery.includes('provider')) {
    const result = await mcpServer.executeTool('get_providers', {
      limit: 10,
      offset: 0
    }, context);
    return formatToolResponse('get_providers', result);
  }

  // Complaints
  if (lowerQuery.includes('≈æalb') || lowerQuery.includes('complaint') || lowerQuery.includes('zalb')) {
    if (!['ADMIN', 'MANAGER', 'AGENT'].includes(context.userRole)) {
      return 'üîí Nemate pristup ≈æalbama. Kontaktirajte administratora.';
    }
    const result = await mcpServer.executeTool('get_complaints', {
      limit: 10,
      offset: 0
    }, context);
    return formatToolResponse('get_complaints', result);
  }

  // Search
  if (lowerQuery.includes('pretra≈æi') || 
      lowerQuery.includes('search') || 
      lowerQuery.includes('pronaƒëi') ||
      lowerQuery.includes('humanitarn')) {
    const searchTerm = extractSearchTerm(query);
    const result = await mcpServer.executeTool('search_entities', {
      query: searchTerm,
      entities: ['contracts', 'providers', 'complaints', 'humanitarian_orgs'],
      limit: 20
    }, context);
    return formatToolResponse('search_entities', result);
  }

  // Stats
  if (lowerQuery.includes('statistik') || lowerQuery.includes('stats')) {
    const result = await mcpServer.executeTool('get_user_stats', {
      period: 'month'
    }, context);
    return formatToolResponse('get_user_stats', result);
  }

  // Default
  return `üí¨ Nisam siguran ≈°ta tra≈æite. Poku≈°ajte:

- "Koje alate imam?" - Lista dostupnih alata
- "Prika≈æi ugovore" - Lista ugovora
- "Prika≈æi provajdere" - Lista provajdera
- "Pretra≈æi Telekom" - Pretraga
- "Statistika" - Va≈°e statistike`;
}

// ===================================
// FORMATTING FUNCTIONS - OSTAJU ISTE
// ===================================

function formatAvailableTools(role: string): string {
  const tools = mcpServer.getToolsForRole(role);
  
  if (tools.length === 0) {
    return `‚ö†Ô∏è Nema dostupnih alata za ulogu: ${role}`;
  }

  const grouped = tools.reduce((acc, tool) => {
    const category = tool.category || 'other';
    if (!acc[category]) acc[category] = [];
    acc[category].push(tool);
    return acc;
  }, {} as Record<string, typeof tools>);

  let result = `üõ†Ô∏è **Dostupni alati za ${role}:**\n\n`;

  Object.entries(grouped).forEach(([category, categoryTools]) => {
    result += `**${category.toUpperCase()}:**\n`;
    categoryTools.forEach(tool => {
      result += `‚Ä¢ **${tool.name}**\n`;
      result += `  ${tool.description}\n`;
      if (tool.examples?.length) {
        result += `  _Primeri: ${tool.examples.slice(0, 2).join(', ')}_\n`;
      }
      result += '\n';
    });
  });

  return result;
}

function getSystemStatus(): string {
  return `üìä **MCP Server Status:**

‚úÖ Server: Operativan
üîß Alati: ${mcpServer.getToolsForRole('ADMIN').length} dostupnih
üíæ Database: Povezana
‚ö° Response: ~${Math.random() * 100 | 0}ms

_Sistem radi normalno._`;
}

function formatToolResponse(toolName: string, result: any): string {
  if (!result.success) {
    return `‚ùå Gre≈°ka: ${result.error || 'Nepoznata gre≈°ka'}`;
  }

  const { data } = result;

  switch (toolName) {
    case 'get_contracts':
      return formatContracts(data);
    case 'get_providers':
      return formatProviders(data);
    case 'get_complaints':
      return formatComplaints(data);
    case 'search_entities':
      return formatSearchResults(data);
    case 'get_user_stats':
      return formatStats(data);
    case 'update_provider':
    case 'create_provider':
      return formatProviderUpdate(data);
    case 'get_activity_overview':
      return formatActivityOverview(data);
    case 'get_system_health':
      return formatSystemHealth(data);
    case 'update_contract':
    case 'create_contract':
      return `‚úÖ Ugovor uspe≈°no ${toolName.includes('create') ? 'kreiran' : 'a≈æuriran'}!\n\n` +
             `ID: ${data.contract?.id}\n` +
             `Naziv: ${data.contract?.name}`;
    case 'create_complaint':
    case 'update_complaint':
      return `‚úÖ ≈Ωalba uspe≈°no ${toolName.includes('create') ? 'kreirana' : 'a≈æurirana'}!\n\n` +
             `ID: ${data.complaint?.id}\n` +
             `Naslov: ${data.complaint?.title}`;
    default:
      return `‚úÖ **Rezultat:**\n\n\`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``;
  }
}

function formatContracts(data: any): string {
  if (!data.contracts?.length) {
    return 'üìã Nema ugovora.';
  }

  let result = `üìã **Ugovori** (${data.displayed}/${data.total})\n\n`;
  
  if (data.summary) {
    result += `‚úÖ Aktivni: ${data.summary.active} | ‚è∞ Istekli: ${data.summary.expired} | ‚è≥ Pending: ${data.summary.pending}\n\n`;
  }

  data.contracts.slice(0, 5).forEach((c: any) => {
    result += `**${c.name}**\n`;
    result += `‚Ä¢ Status: ${c.status}\n`;
    result += `‚Ä¢ Provajder: ${c.provider?.name || 'N/A'}\n`;
    result += `‚Ä¢ Broj: ${c.contractNumber || 'N/A'}\n`;
    result += `‚Ä¢ Period: ${new Date(c.startDate).toLocaleDateString('sr-RS')} - ${new Date(c.endDate).toLocaleDateString('sr-RS')}\n\n`;
  });

  if (data.contracts.length > 5) {
    result += `_... i jo≈° ${data.contracts.length - 5} ugovora_`;
  }

  return result;
}

function formatProviders(data: any): string {
  if (!data.providers?.length) {
    return 'üè¢ Nema provajdera.';
  }

  let result = `üè¢ **Provajderi** (${data.displayed}/${data.total})\n\n`;

  data.providers.slice(0, 5).forEach((p: any) => {
    result += `**${p.name}**\n`;
    result += `‚Ä¢ Status: ${p.isActive ? '‚úÖ Aktivan' : '‚ùå Neaktivan'}\n`;
    result += `‚Ä¢ Ugovori: ${p._count?.contracts || 0}\n`;
    result += `‚Ä¢ ≈Ωalbe: ${p._count?.complaints || 0}\n\n`;
  });

  return result;
}

function formatComplaints(data: any): string {
  if (!data.complaints?.length) {
    return 'üìù Nema ≈æalbi.';
  }

  let result = `üìù **≈Ωalbe** (${data.displayed}/${data.total})\n\n`;

  if (data.summary) {
    result += `üÜï Nove: ${data.summary.new} | ‚öôÔ∏è U toku: ${data.summary.inProgress} | ‚úÖ Re≈°ene: ${data.summary.resolved}\n\n`;
  }

  data.complaints.slice(0, 5).forEach((c: any) => {
    result += `**${c.title}**\n`;
    result += `‚Ä¢ Status: ${c.status}\n`;
    result += `‚Ä¢ Prioritet: ${c.priority || 'N/A'}\n`;
    result += `‚Ä¢ Provajder: ${c.provider?.name || 'N/A'}\n\n`;
  });

  return result;
}

function formatSearchResults(data: any): string {
  let result = `üîç **Rezultati pretrage:**\n\n`;
  let hasResults = false;

  if (data.contracts?.length) {
    hasResults = true;
    result += `üìã **Ugovori (${data.contractsTotal}):**\n`;
    data.contracts.slice(0, 3).forEach((c: any) => {
      result += `‚Ä¢ ${c.name} (${c.status})\n`;
    });
    result += '\n';
  }

  if (data.providers?.length) {
    hasResults = true;
    result += `üè¢ **Provajderi (${data.providersTotal}):**\n`;
    data.providers.slice(0, 3).forEach((p: any) => {
      result += `‚Ä¢ ${p.name} ${p.isActive ? '‚úÖ' : '‚ùå'}\n`;
    });
    result += '\n';
  }

  if (data.complaints?.length) {
    hasResults = true;
    result += `üìù **≈Ωalbe (${data.complaintsTotal}):**\n`;
    data.complaints.slice(0, 3).forEach((c: any) => {
      result += `‚Ä¢ ${c.title} (${c.status})\n`;
    });
    result += '\n';
  }

  if (data.humanitarianOrgs?.length) {
    hasResults = true;
    result += `ü§ù **Humanitarne org. (${data.humanitarianOrgsTotal}):**\n`;
    data.humanitarianOrgs.slice(0, 3).forEach((h: any) => {
      result += `‚Ä¢ ${h.name}${h.shortNumber ? ` (${h.shortNumber})` : ''}\n`;
    });
  }

  if (!hasResults) {
    return 'üîç Nema rezultata pretrage.';
  }

  return result;
}

function formatStats(data: any): string {
  const { period, stats } = data;
  return `üìä **Tvoja statistika - ${period}:**

üìã Kreirani ugovori: ${stats.contractsCreated}
üìù Podnesene ≈æalbe: ${stats.complaintsSubmitted}
‚ö° Ukupne aktivnosti: ${stats.activitiesCount}`;
}

function formatProviderUpdate(data: any): string {
  if (!data.provider) {
    return '‚ùå Gre≈°ka pri a≈æuriranju provajdera.';
  }

  const p = data.provider;
  return `‚úÖ **Provajder uspe≈°no a≈æuriran**

**${p.name}**
- Email: ${p.email || 'N/A'}
- Telefon: ${p.phone || 'N/A'}
- Status: ${p.isActive ? '‚úÖ Aktivan' : '‚ùå Neaktivan'}
- Adresa: ${p.address || 'N/A'}

_A≈æurirano: ${new Date(p.updatedAt).toLocaleString('sr-RS')}_`;
}

function formatActivityOverview(data: any): string {
  const { period, overview } = data;
  return `üìä **Pregled aktivnosti - ${period}**

üìã Novi ugovori: ${overview.newContracts}
‚ö†Ô∏è Ugovori koji istiƒçu (30 dana): ${overview.expiringContracts}
üìù Nove ≈æalbe: ${overview.newComplaints}
üîÑ Aktivna obnavljanja: ${overview.activeRenewals}
‚ö° Nedavne aktivnosti: ${overview.recentActivities}`;
}

function formatSystemHealth(data: any): string {
  const { system } = data;
  return `üè• **Zdravlje sistema**

üë• Korisnici:
- Ukupno: ${system.users.total}
- Aktivni: ${system.users.active}

üìã Ugovori:
- Ukupno: ${system.contracts.total}
- Aktivni: ${system.contracts.active}

üìù ≈Ωalbe:
- Na ƒçekanju: ${system.complaints.pending}

‚úÖ Sistem radi normalno`;
}

function extractSearchTerm(query: string): string {
  const match = query.match(/pretra≈æi\s+(.+)|search\s+(.+)|pronaƒëi\s+(.+)/i);
  return match ? (match[1] || match[2] || match[3]).trim() : query;
}